{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf230
{\fonttbl\f0\fnil\fcharset0 Verdana;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\fi720\pardirnatural

\f0\b\fs28 \cf0 Outside In Development
\b0 \
\
This failure defines the target for our next coding episode. It tells us, at a high level, what we\'92re aiming for - we just have to fill in implementation until it passes.\
\
Our approach to TDD is to start with the outside event that triggers the behavior we want to implement and work our way into the code an object at a time, until we reach a visible effect (such as a sent message or log entry) indicating that we\'92ve achieved our goal. The end-to-end test shows us the end points of that process, so we can explore our way through the space in the middle.\
\
How can we hope to catch all the configuration options in an entire system? At some level we can\'92t, and this is at the heart of what professional testers do. What we can do is push to exercise as much as possible of the system as early as possible, and to do so repeatedly. We can also help ourselves cope with total system complexity by keeping the quality of its components high and by constantly pushing to simplify.\
\

\b Use nil When an Argument Doesn\'92t Matter
\b0 \
\
Pass in a nil value to satisfy the compiler but use a named constant to make clear its significance.\
\

\b Discovering Further Work
\b0 \
\
We don\'92t want to break the flow of getting features to work, so we add error handling to the to-do list to come back to it later.\
\

\b Finish the Job
\b0 \
\
Decide what we want to say and how to say it: we write a high-level end-to-end test to describe what the system should implement. We use descriptive test names to tell us what a class does; we extract new classes to tease apart fine-grained aspects of the functionality; and we write lots of little method to keep each layer of code at a consistent level of abstraction. But first, we write a rough implementation to prove that we know how to make the code do what\'92s required and then we refactor. \
\
First-cut code is not finished. It\'92s good enough to sort out our ideas and make sure we have everything in place, but it\'92s unlikely to express its intentions cleanly. That will make it a drag on productivity as it\'92s read repeatedly over the lifetime of the code. \
\

\b Focus, Focus, Focus
\b0 \
\
Once again, we\'92ve noticed complexity in a class and used that to tease out a new concept from our initial skeleton implementation.\
\

\b How Should We Describe Expected Values
\b0 \
\
We\'92ve specified the expected bid value by adding the price and increment. There are different opinions about whether test values should just be literals with obvious values, or expressed in terms of the calculation they represent. Writing out the calculation may make the test more readable but risks reimplementing the target code in the test, and in some cases the calculation will be too complicated to reproduce. Here, we decide that the calculation is so trivial that we can just write it into the test.\
\
This is our first test with more than one expectation, so we\'92ll point out that the order in which expectations are declared does not have to match the order in which the methods are called in the code. If the calling order does matter, the expectations should include a sequence clause.\
\

\b Null Implementation
\b0 \
\
We define a null implementation as a temporary empty implementation, introduced to allow the programmer to make progress by deferring effort and intended to be replaced.\
\

\b The End-to-End Tests Pass
\b0 \
\
Now the end-to-end tests pass. We can cross off another item on the to-do list, but that includes just catching and printing XYZException. Normally, we regard this as a very bad practice but we wanted to see the tests pass and get some structure into the code - and we know that the end-to-end tests will fail anyway if there\'92s a problem sending a message. To make sure we don\'92t forget, we add another to-do item to find a better solution.\
\

\b Defer Decisions
\b0 \
\
Introduce a null implementation of a method (or even a type) to get us through the next step. This helps us focus on the immediate task without getting dragged into thinking about the next significant chunk of functionality.\
\

\b Keep the Code Compiling
\b0 \
\
Minimize the time when we have to code that does not compile by keeping changes incremental.  When we have compilation failures compilers cannot tell us where the boundaries of our changes are. This means we cannot check-in often. The more code we have open, the more we have to keep in our heads which, ironically, usually means we move more slowly. One of the great discoveries of TDD is just how fine-grained our development steps can be.\
\

\b Emergent Design
\b0 \
\
We\'92re growing a design from what looks like an unpromising start. We alternate between adding features and reflecting on and cleaning up the code that results. The cleaning up stage is essential, since without it we would end up with an unmaintainable mess. We\'92re prepared to defer refactoring code if we\'92re not yet clear what to do, confident that we will take the time when we\'92re ready. In the meantime, we keep our code as clean as possible, moving in small increments and using techniques such as null implementation to minimize the time when it\'92s broken.\
\
}