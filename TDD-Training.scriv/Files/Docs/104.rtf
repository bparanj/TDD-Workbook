{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf230
{\fonttbl\f0\fnil\fcharset0 Verdana;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\fi720\pardirnatural

\f0\fs28 \cf0 Test after vs Test first\
Test-by-test vs Test all-at-once\
Outside-in vs Inside-out (applies independently to design and coding)\
Behavior verification vs State verification\
Fixture designed test-by-test vs Big fixture design upfront\
\

\b Test First or Last?
\b0 \
\
When tests are written first and we write only enough code to make the tests pass, the production code tends to be more minimalist.\
\
Examples are easier for people to envision writing before code than tests. Examples are executable and reveal whether the requirements have been satisfied. Executable specification mindset has lead to frameworks like RSpec.\
\

\b State or Behavior Verification?
\b0 \
\
From writing code outside-in, it is but a small step to verifying behavior rather than just state. The statist view suggest that it is sufficient to put the SUT into a specific state, exercise it, and verify that the SUT is in the expected state at the end of the test. The behaviorist view says that we should specify not only the start and end states of the SUT, but also the calls the SUT makes to its dependencies. That is, we should specify the details of the calls to the outgoing interfaces of the SUT. These indirect outputs of the SUT are outputs just like the values returned by functions, except that we must use special measures to trap them because they do not come directly back to the client or test.\
\
The behaviorist school of thought is sometimes called behavior-driven development. It is evidenced by the copious use of mock objects or test spies throughout the tests. Behavior verification does a better job of testing each unit of software in isolation, albeit at a possible cost of more difficult refactoring. \
\

\b Summary
\b0 \
\
Write the tests first\
Tests are examples\
Write tests one at a time. It is ok to list all the tests you can think of as skeletons upfront.\
Outside-in development helps clarify which tests are needed for the next layer inward\
Use primarily state verification. Resort to behavior verification when needed to get good code coverage.\
Perform fixture design on a test-by-test basis.\
}