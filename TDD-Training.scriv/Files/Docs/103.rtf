{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf230
{\fonttbl\f0\fnil\fcharset0 Verdana;\f1\fnil\fcharset0 Georgia;}
{\colortbl;\red255\green255\blue255;\red38\green0\blue0;\red223\green223\blue212;}
\pard\tx720\fi720\pardirnatural

\f0\fs28 \cf0 High level objectives:\
\
Tests should help us improve quality\
Tests should help us understand the SUT\
Tests should reduce and not introduce risk\
Tests should be easy to run\
Tests should be easy to write and maintain\
Tests should require minimal maintenance as the system evolves around them\
\
The first three objectives demonstrate the value provided by the tests, whereas the last three objectives focus on the characteristics of the tests themselves. \
\

\b\fs32 Tests Should Help Us Improve Quality
\b0 \

\fs28 \

\b Goal : Tests as Specification 
\b0 \
\
Executable Specification\
\
TDD enable us to specify the behavior in various scenarios captured in a form that we can then execute. To ensure that we are building the right software, we must ensure that our tests reflect how the SUT will actually be used. This effort can be facilitated by developing user interface mockups that capture just enough detail about how the application appears and behaves so that we can write our tests.\
\
The very act of thinking through various scenarios in enough detail to turn them into tests helps us identify those areas where the requirements are ambiguous or self-contradictory. Such analysis improves the quality of the specification, which improves the quality of the software.\
\

\b Goal : Defect Localization
\b0 \
\
If our unit tests are small (i.e., we test only a single behavior in each one), we should be able to pinpoint the bug quickly based on which test fails. This specificity is one of the major advantages that unit tests enjoy over customer tests. The customer tests tell us that some behavior expected by the customer isn\'92t working; the unit tests tell us why. This is defect localization. If a customer test fails but no unit tests fail, it indicates a missing unit test.\
\
Write tests for all possible scenarios that each unit of software needs to cover. If the tests contain bugs we cannot achieve any benefits. It is crucial that we keep the tests as simple as possible so that they can be easily seen to be correct. While writing unit tests for our unit tests is not a practical solution, we can and should write unit tests for any test utility method to which we delegate complex algorithms needed by the test methods.\
\

\b\fs32 Tests Should Help Us Understand the SUT
\b0\fs28 \
\
The tests can show the reader how the code is supposed to work. \
\

\b Goal: Tests as Documentation
\b0 \
\
Tests Should Reduce and Not Introduce Risk\
\
One form of risk reduction involve verifying the software\'92s behavior in the impossible circumstances that cannot be induced when doing traditional customer testing of the entire application as a black box. \
\

\b Goal : Tests as Safety Net
\b0 \
\
The effectiveness of the safety net is determined by how completely our test verify the behavior of the system. Missing tests are like holes in the safety net. \
\

\b Goal: Do No Harm
\b0 \
\
No Test Risk\
\
How might automated tests introduce risk? Avoid putting test-specific hooks into the SUT. Any test specific code should be plugged in by the test and only in the test environment. It should not exist in the SUT when it is in production.\
\
A common mistake is replacing too much of the SUT with a test double. We must be clear about which SUT we are testing and avoid replacing the parts we are testing with test-specific logic.\
\

\b\fs32 Tests Should Be Easy to Run
\b0\fs28 \
\
They must be fully automated tests so they can be run without any effort.\
They must be self checking tests so they can detect and report any errors without manual inspection\
They must be repeatable tests so they can be run multiple times with the same result.\
Ideally each test should be an independent test that can be run by itself.\
\

\b Goal : Repeatable Test
\b0 \
\
Tests that run only in memory and that use only local variables or fields are usually repeatable. Unrepeatable tests are caused by using a shared fixture. In such a case, we must ensure that our tests are self-cleaning. \
\

\b Tests Should Be Easy to Write and Maintain
\b0 \
\
Coding is a difficult activity because we must keep a lot of information in our heads as we work. When we are writing tests, we should stay focused on 
\i testing
\i0  rather than 
\i coding 
\i0 of the tests. This means that tests must be simple. Simple to read and simple to write. They need to be simple to read and understand because testing the automated tests themselves is a complicated endeavor. \
\
\pard\pardeftab720

\f1 \cf2 \cb3 Everyone knows that debugging is twice as hard as writing a program in the first place.\'a0 So if you are as clever as you can be when you write it, how will you ever debug it?\'a0 ~Brian Kernighan
\f0 \cf0 \cb1 \
\pard\tx720\fi720\pardirnatural
\cf0 \
They can be tested properly only by introducing the very bugs that they are intended to detect in the SUT. This is hard to do in an automated way so it is usually done only once (if at all), when the test is first written. For these reasons, we need to rely on our eyes to catch any problems that creep into the tests, and that means we must keep the tests simple enough to read quickly.\
\
Tests become complicated for two reasons:\
\
We try to verify too much functionality in a single test.\
Too large an expressiveness gap separates the test scripting language and the before/after relationships between domain concepts that we are trying to express in the test.\
\

\b Goal : Simple Tests
\b0 \
\
Strive to verify one condition per test by creating a test method for each unique combination of pre-test state and input. Each test method should drive the SUT through a single code path. Customer tests are exception to this rule.\
\

\b Goal : Expressive Tests
\b0 \
\
The expressiveness gap can be addressed by building up a library of test utility methods that constitute a domain-specific testing language. Such a collection of methods allows us to express the concepts that we wish to test without having to translate our thoughts into much more detailed code. \
\
Avoid duplication in tests. There is, however, a counterforce at play. Because the tests should communicate intent, it is best to keep the core test logic in each test method so it can be seen in one place. This doesn\'92t preclude moving a lot of supporting code into test utility methods where it needs to be modified in only one place if it is affected by a change in the SUT.\
\

\b Goal : Separation of Concerns
\b0 \
\
1. We want to keep test code separate from our production code\
2. We want each test to focus on a single concern\
\
Test concerns separately to void obscure tests.\
\

\b Tests Should Require Minimal Maintenance as the System Evolves Around Them\

\b0 \
We write automated tests mostly to make change easier, so we should strive to ensure that our tests don\'92t inadvertently make change more difficult.\
\

\b Goal : Robust Test
\b0 \
\
We want to write our tests in such a way that the number of tests affected by any one change is small. That means we need to minimize overlap between tests. We also need to ensure that changes to the test environment don\'92t affect our tests. We do this by isolating the SUT from the environment as much as possible.\
\
Strive to verify one condition per test. Ideally, only one kind of change should cause a test to require maintenance. System changes that affect fixture setup or teardown code can be encapsulated behind test utility methods to reduce the number of tests affected by the change.\
}