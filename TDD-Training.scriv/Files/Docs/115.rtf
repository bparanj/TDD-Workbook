{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf230
{\fonttbl\f0\fnil\fcharset0 Verdana;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\fi720\pardirnatural

\f0\fs28 \cf0 Testing is no longer just about keeping defects from the users; instead, it\'92s about helping the team to understand the features that the users need and to deliver those features reliably and predictably.\
\

\b What is the Point of TDD?\

\b0 \
One must learn by doing the thing; for though you think you know it, you have no certainty, until you try it.\
\

\b Software Development as a Learning Process\

\b0 \
Everyone involved in a software project has to learn as it progresses. For the project to succeed, the people involved have to work together just to understand what they\'92re supposed to achieve and to identify and resolve misunderstanding along the way. They all know there will be changes, they just don\'92t 
\i what 
\i0 changes. They need a process that will help them cope with uncertainty as their experience grows - to 
\i anticipate unanticipated changes
\i0 .\
\

\b Feedback is the Fundamental Tool\

\b0 \
The best approach a team can take is to use 
\i empirical feedback
\i0  to learn about the system and its use, and then apply that learning back to the system. A team needs repeated cycles of activity. In each cycle it adds new features and gets feedback about the quantity and quality of the work already done. The team members split the work into time boxes, within which they analyze, design, implement, and deploy as many features as they can.\
\

\b The fundamental TDD Cycle\

\b0 \
As we develop the system, we use TDD to give us feedback on the quality of both its implementation (Does it work?) and design (Is it well structured?). \
\
Writing tests:\
\
Makes us clarify the acceptance criteria for the next piece of work - we have to ask ourselves how we can tell when we\'92re done (design)\
Encourages us to write loosely coupled components, so they can easily be tested in isolation and, at higher levels, combined together (design)\
Adds an executable description of what the code does (design)\
Adds to a complete regression suite (implementation)\
\
Running tests:\
\
Detects errors while the context is fresh in our mind (implementation)\
Lets us know when we\'92ve done enough, discouraging gold plating and unnecessary features (design)\
\

\b The Bigger Picture\

\b0 \
When implementing a feature, start by writing an acceptance test, which exercises the functionality we want to build. While it\'92s failing, an acceptance test demonstrates that the system does not yet implement that feature; when it passes, we\'92re done. When working on a feature, we use its acceptance test to guide us as to whether we actually need the code we\'92re about to write - we only write code that\'92s directly relevant. Underneath the acceptance test, we follow the unit level test/implement/refactor cycle to develop the feature; the whole cycle looks like:\
\
Fig 1.2 Inner and Outer Feedback Loops in TDD\
\
The outer test loop is a measure of demonstrable progress, and the growing suite of tests protects us against regression failures when we change the system. Acceptance tests often take a while to make pass, certainly more than one check-in episode, so we usually distinguish between acceptance tests we\'92re working on (which are not yet included in the build) and acceptance tests for the features that have been finished (which are included in the build and must always pass).\
\
The inner loop supports the developers. The unit tests help us maintain the quality of the code and should pass soon after they\'92ve been written. \
\

\b Testing End-to-End\

\b0 \
Wherever possible, an acceptance test should exercise the system end-to-end without directly calling its internal code. An 
\i end-to-end test
\i0  interacts with the system only from the outside: through its user interface, by sending messages as if from third-party systems, by invoking its web services, by parsing reports and so on. The whole behavior of the system includes its interaction with its external environment. This is often the riskiest and most difficult aspect; we ignore it at our peril. We try to avoid acceptance tests that just exercise the internal objects of the system, unless we really need the speed-up and already have a stable set of end-to-end tests to provide cover.\
\

\b Levels of Testing\

\b0 \
Acceptance : Does the whole system work?\
Integration : Does our code work against code we can\'92t change?\
Unit : Do our objects do the right thing, are they convenient to work with?\
\
We use acceptance tests to help us, with the domain experts, understand and agree on what we are going to build next. We also use them to make sure that we haven\'92t broken any existing features as we continue developing. \
\
Integration tests refer to the tests that check how some of our code works with code from outside the team that we can\'92t change. It might be a public framework or library from another team within our company. The distinction is that integration tests make sure that any abstractions we build over third-party code work as we expect. They help tease out configuration issues and to give quicker feedback than the slower acceptance tests.\
\
A unit test for an objects needs to create the object, provide its dependencies, interact with it, and check that it behaved as expected. So, for a class to be easy to unit-test, the class must have explicit dependencies that can easily be substituted and clear responsibilities that can easily be invoked and verified. This means that the code must be loosely coupled and highly cohesive.}